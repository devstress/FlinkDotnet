name: Local Testing - Interactive Environment Validation

on:
  workflow_call:
  workflow_dispatch:

jobs:
  run-local-testing-validation:
    name: Run Local Testing Interactive Environment Validation
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure Docker is running
        run: docker info

      - name: Set up .NET 9.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Install .NET Aspire workload
        run: |
          Write-Host "ðŸ“¦ Installing .NET Aspire workload..." -ForegroundColor Green
          dotnet workload install aspire
          Write-Host "âœ… Aspire workload installed successfully" -ForegroundColor Green

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-solutions

      - name: Build LocalTesting Solution
        run: |
          Write-Host "ðŸ”¨ Building LocalTesting solution..." -ForegroundColor Green
          dotnet restore LocalTesting/LocalTesting.sln
          dotnet build LocalTesting/LocalTesting.sln --configuration Release --no-restore

      - name: Verify LocalTesting Build Artifacts
        run: |
          Write-Host "ðŸ” Verifying LocalTesting build artifacts..." -ForegroundColor Green
          
          $appHostDll = "LocalTesting/LocalTesting.AppHost/bin/Release/net9.0/LocalTesting.AppHost.dll"
          $webApiDll = "LocalTesting/LocalTesting.WebApi/bin/Release/net9.0/LocalTesting.WebApi.dll"
          
          if (Test-Path $appHostDll) {
            Write-Host "âœ… AppHost build artifact found: $appHostDll" -ForegroundColor Green
          } else {
            Write-Host "âŒ AppHost build artifact missing: $appHostDll" -ForegroundColor Red
            throw "LocalTesting.AppHost build failed"
          }
          
          if (Test-Path $webApiDll) {
            Write-Host "âœ… WebApi build artifact found: $webApiDll" -ForegroundColor Green
          } else {
            Write-Host "âŒ WebApi build artifact missing: $webApiDll" -ForegroundColor Red
            throw "LocalTesting.WebApi build failed"
          }

      - name: Start LocalTesting Aspire Environment
        timeout-minutes: 15
        run: |
          Write-Host "ðŸš€ Starting LocalTesting Aspire environment..." -ForegroundColor Green
          
          # Verify Aspire is working by testing the project build
          Write-Host "Verifying Aspire functionality..." -ForegroundColor Yellow
          Push-Location LocalTesting/LocalTesting.AppHost
          try {
            $buildOutput = dotnet build --configuration Release --verbosity quiet 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "âœ… Aspire is functional and project builds successfully" -ForegroundColor Green
            } else {
              Write-Host "âŒ Aspire build failed. Output:" -ForegroundColor Red
              Write-Host $buildOutput -ForegroundColor Red
              throw "Aspire functionality test failed"
            }
          }
          catch {
            Write-Host "âŒ Aspire verification failed: $($_.Exception.Message)" -ForegroundColor Red
            throw "Aspire is not properly configured"
          }
          finally {
            Pop-Location
          }
          
          # Start the Aspire environment as a background process
          Push-Location LocalTesting/LocalTesting.AppHost
          
          # Set DCP and Dashboard paths for Aspire orchestration first
          $nugetPackages = "$HOME/.nuget/packages"
          
          # Set DCP CLI path using the installed orchestration package
          $dcpPath = "$nugetPackages/aspire.hosting.orchestration.linux-x64/9.1.0/tools/dcp"
          if (Test-Path $dcpPath) {
            $env:DCP_CLI_PATH = $dcpPath
            Write-Host "âœ… DCP CLI path set: $dcpPath" -ForegroundColor Green
          } else {
            Write-Host "âŒ DCP CLI path not found at expected location: $dcpPath" -ForegroundColor Red
            throw "DCP CLI path is required but not found"
          }
          
          # Set Aspire Dashboard path using the installed dashboard SDK
          $dashboardPath = "$nugetPackages/aspire.dashboard.sdk.linux-x64/9.1.0/tools"  
          if (Test-Path $dashboardPath) {
            $env:ASPIRE_DASHBOARD_PATH = $dashboardPath
            Write-Host "âœ… Aspire Dashboard path set: $dashboardPath" -ForegroundColor Green
          } else {
            Write-Host "âŒ Aspire Dashboard path not found at expected location: $dashboardPath" -ForegroundColor Red
            throw "Aspire Dashboard path is required but not found"
          }
          
          # Set all required environment variables for Aspire
          $env:ASPIRE_ALLOW_UNSECURED_TRANSPORT = "true"
          $env:ASPNETCORE_URLS = "http://localhost:15000"
          $env:DOTNET_DASHBOARD_OTLP_ENDPOINT_URL = "http://localhost:4323"
          $env:DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL = "http://localhost:4324" 
          $env:ASPIRE_DASHBOARD_URL = "http://localhost:18888"
          $env:ASPNETCORE_ENVIRONMENT = "Development"
          $env:DOTNET_LAUNCH_PROFILE = ""
          
          Write-Host "Environment variables set:" -ForegroundColor Yellow
          Write-Host "  ASPNETCORE_URLS: $env:ASPNETCORE_URLS" -ForegroundColor Cyan
          Write-Host "  ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL: $env:ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL" -ForegroundColor Cyan
          Write-Host "  ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL: $env:ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL" -ForegroundColor Cyan
          Write-Host "  DCP_CLI_PATH: $env:DCP_CLI_PATH" -ForegroundColor Cyan
          Write-Host "  ASPIRE_DASHBOARD_PATH: $env:ASPIRE_DASHBOARD_PATH" -ForegroundColor Cyan
          
          Write-Host "Starting Aspire AppHost as background process..." -ForegroundColor Yellow
          try {
            # Start Aspire as a background process and capture the process ID
            $aspireProcess = Start-Process -FilePath "dotnet" -ArgumentList "run", "--configuration", "Release" -PassThru -RedirectStandardOutput "aspire_output.log" -RedirectStandardError "aspire_error.log" -NoNewWindow
            $global:AspirePID = $aspireProcess.Id
            Write-Host "âœ… Aspire AppHost started in background (PID: $global:AspirePID)" -ForegroundColor Green
            
            # Wait for initial startup and check for startup success
            Write-Host "Waiting for Aspire to initialize..." -ForegroundColor Yellow
            Start-Sleep -Seconds 45
            
            # Check startup output
            $startupOutput = ""
            if (Test-Path "aspire_output.log") {
              $startupOutput += Get-Content "aspire_output.log" -Raw
            }
            if (Test-Path "aspire_error.log") {
              $errorOutput = Get-Content "aspire_error.log" -Raw
              if ($errorOutput) {
                $startupOutput += "`nErrors: $errorOutput"
              }
            }
            
            # Check for startup success indicators
            if ($startupOutput -match "Distributed application starting" -and $startupOutput -match "Aspire version") {
              Write-Host "âœ… Aspire environment startup successful" -ForegroundColor Green
            } else {
              Write-Host "âŒ Aspire startup may have failed - missing expected startup messages:" -ForegroundColor Red
              Write-Host $startupOutput -ForegroundColor Red
              throw "Aspire startup failed with configuration errors"
            }
          }
          catch {
            Write-Host "âŒ Failed to start Aspire environment: $($_.Exception.Message)" -ForegroundColor Red
            if ($startupOutput) {
              Write-Host "Startup output:" -ForegroundColor Yellow
              Write-Host $startupOutput -ForegroundColor Yellow
            }
            
            Pop-Location
            throw "Aspire environment startup failed: $($_.Exception.Message)"
          }
          
          Pop-Location

      - name: Wait for Services to Start
        timeout-minutes: 8
        run: |
          Write-Host "â³ Waiting for services to start and become healthy..." -ForegroundColor Green
          
          # Wait for services to start (give them more time to initialize, especially Temporal)
          Write-Host "Waiting for basic containers to start..." -ForegroundColor Yellow
          Start-Sleep -Seconds 60
          
          Write-Host "Checking initial container status..." -ForegroundColor Yellow
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          Write-Host "Waiting additional time for Temporal stack to initialize..." -ForegroundColor Yellow
          Start-Sleep -Seconds 120
          
          Write-Host "Checking Docker containers..." -ForegroundColor Yellow
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          # Check if we have some containers running
          $containerCount = (docker ps --format "{{.Names}}" | Measure-Object).Count
          Write-Host "Found $containerCount running containers" -ForegroundColor Cyan
          
          # Show any containers that failed to start
          $failedContainers = docker ps -a --filter "status=exited" --format "{{.Names}}"
          if ($failedContainers) {
            Write-Host "âš ï¸ Containers that failed to start:" -ForegroundColor Yellow
            $failedContainers | ForEach-Object { 
              Write-Host "  - $_" -ForegroundColor Red
              Write-Host "    Last few log lines:" -ForegroundColor Yellow
              docker logs --tail 10 $_ 2>&1 | ForEach-Object { Write-Host "      $_" -ForegroundColor Cyan }
            }
          }
          
          if ($containerCount -eq 0) {
            Write-Host "âŒ No Docker containers are running. Aspire environment failed to start properly." -ForegroundColor Red
            throw "Aspire environment startup failed - no containers are running"
          }
          
          Write-Host "âœ… $containerCount containers are running" -ForegroundColor Green

      - name: Validate Infrastructure Components and API Accessibility
        timeout-minutes: 8
        run: |
          Write-Host "ðŸ” Validating infrastructure components and API accessibility..." -ForegroundColor Green
          
          $missingServices = @()
          
          # Check for Kafka containers
          $kafkaContainers = docker ps --filter "name=kafka" --format "{{.Names}}"
          if ($kafkaContainers) {
            Write-Host "âœ… Kafka containers found:" -ForegroundColor Green
            $kafkaContainers | ForEach-Object { Write-Host "  - $_" -ForegroundColor Cyan }
          } else {
            Write-Host "âŒ No Kafka containers found" -ForegroundColor Red
            $missingServices += "Kafka"
          }
          
          # Check for Flink containers
          $flinkContainers = docker ps --filter "name=flink" --format "{{.Names}}"
          if ($flinkContainers) {
            Write-Host "âœ… Flink containers found:" -ForegroundColor Green
            $flinkContainers | ForEach-Object { Write-Host "  - $_" -ForegroundColor Cyan }
          } else {
            Write-Host "âŒ No Flink containers found" -ForegroundColor Red
            $missingServices += "Flink"
          }
          
          # Check for Redis containers
          $redisContainers = docker ps --filter "name=redis" --format "{{.Names}}"
          if ($redisContainers) {
            Write-Host "âœ… Redis containers found:" -ForegroundColor Green
            $redisContainers | ForEach-Object { Write-Host "  - $_" -ForegroundColor Cyan }
          } else {
            Write-Host "âŒ No Redis containers found" -ForegroundColor Red
            $missingServices += "Redis"
          }
          
          # Check for Temporal containers (all three: postgres, server, ui)
          $temporalContainers = docker ps --filter "name=temporal" --format "{{.Names}}"
          if ($temporalContainers) {
            Write-Host "âœ… Temporal containers found:" -ForegroundColor Green
            $temporalContainers | ForEach-Object { Write-Host "  - $_" -ForegroundColor Cyan }
            
            # Verify we have all required Temporal components
            $hasPostgres = $temporalContainers | Where-Object { $_ -match "postgres" }
            $hasServer = $temporalContainers | Where-Object { $_ -match "server" -and $_ -notmatch "postgres" }
            $hasUI = $temporalContainers | Where-Object { $_ -match "ui" -and $_ -notmatch "server" }
            
            if (-not $hasPostgres) {
              Write-Host "âŒ Temporal PostgreSQL container missing" -ForegroundColor Red
              $missingServices += "Temporal PostgreSQL"
            }
            if (-not $hasServer) {
              Write-Host "âŒ Temporal Server container missing" -ForegroundColor Red
              $missingServices += "Temporal Server"
            }
            if (-not $hasUI) {
              Write-Host "âŒ Temporal UI container missing" -ForegroundColor Red
              $missingServices += "Temporal UI"
            }
          } else {
            Write-Host "âŒ No Temporal containers found" -ForegroundColor Red
            $missingServices += "Temporal (PostgreSQL, Server, UI)"
          }
          
          # Show detailed container information for debugging
          Write-Host "`nðŸ” All running containers for debugging:" -ForegroundColor Yellow
          docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
          
          # Check for failed containers that might give us clues
          $failedContainers = docker ps -a --filter "status=exited" --format "{{.Names}}"
          if ($failedContainers) {
            Write-Host "`nâš ï¸ Failed containers found:" -ForegroundColor Yellow
            $failedContainers | ForEach-Object { 
              Write-Host "  - $_" -ForegroundColor Red
              Write-Host "    Exit status and logs:" -ForegroundColor Yellow
              docker inspect $_ --format "{{.State.ExitCode}}: {{.State.Error}}"
              Write-Host "    Last 5 log lines:" -ForegroundColor Yellow
              docker logs --tail 5 $_ 2>&1 | ForEach-Object { Write-Host "      $_" -ForegroundColor Cyan }
            }
          }
          
          # Test API endpoint accessibility for all services including LocalTesting API
          Write-Host "`nðŸŒ Testing API and UI endpoint accessibility..." -ForegroundColor Green
          
          # Check if we can reach the LocalTesting API and other UI endpoints
          $testEndpoints = @(
            @{Port=5000; Name="LocalTesting API"; Path="/"; Critical=$true},
            @{Port=8082; Name="Kafka UI"; Path="/"; Critical=$false},
            @{Port=8084; Name="Temporal UI"; Path="/"; Critical=$true},
            @{Port=3000; Name="Grafana"; Path="/"; Critical=$false},
            @{Port=8081; Name="Flink JobManager UI"; Path="/"; Critical=$false}
          )
          
          $accessibleEndpoints = @()
          $failedEndpoints = @()
          $endpointMissingServices = @()
          
          foreach ($endpoint in $testEndpoints) {
            try {
              Write-Host "Testing $($endpoint.Name) on port $($endpoint.Port)..." -ForegroundColor Yellow
              $uri = "http://localhost:$($endpoint.Port)$($endpoint.Path)"
              $response = Invoke-WebRequest -Uri $uri -TimeoutSec 10 -ErrorAction SilentlyContinue
              if ($response.StatusCode -eq 200) {
                Write-Host "âœ… $($endpoint.Name) is accessible (Status: $($response.StatusCode))" -ForegroundColor Green
                $accessibleEndpoints += $endpoint.Name
              }
            }
            catch {
              Write-Host "âŒ $($endpoint.Name) not accessible: $($_.Exception.Message)" -ForegroundColor Red
              $failedEndpoints += $endpoint.Name
              if ($endpoint.Critical) {
                $endpointMissingServices += $endpoint.Name
              }
            }
          }
          
          # Combine container validation failures with endpoint failures (avoiding duplicates)
          $allMissingServices = $missingServices + $endpointMissingServices | Select-Object -Unique
          
          # Combined validation: fail if either containers are missing OR critical APIs are inaccessible
          if ($allMissingServices.Count -gt 0) {
            Write-Host "`nâŒ Missing critical infrastructure services: $($allMissingServices -join ', ')" -ForegroundColor Red
            Write-Host "This indicates that the Aspire environment failed to start all required services." -ForegroundColor Red
            
            if ($accessibleEndpoints.Count -gt 0) {
              Write-Host "âœ… Accessible services: $($accessibleEndpoints -join ', ')" -ForegroundColor Green
            }
            if ($failedEndpoints.Count -gt 0) {
              Write-Host "âŒ Failed services: $($failedEndpoints -join ', ')" -ForegroundColor Red
            }
            
            throw "Critical infrastructure services are missing: $($allMissingServices -join ', '). Aspire environment startup failed."
          }
          
          Write-Host "`nâœ… All critical infrastructure components and APIs are running and accessible" -ForegroundColor Green
          Write-Host "âœ… Accessible services: $($accessibleEndpoints -join ', ')" -ForegroundColor Green
          if ($failedEndpoints.Count -gt 0) {
            Write-Host "âš ï¸ Inaccessible non-critical services: $($failedEndpoints -join ', ')" -ForegroundColor Yellow
          }

      - name: Execute Complex Logic Stress Test Business Flows
        timeout-minutes: 20
        run: |
          Write-Host "ðŸ§ª Executing Complex Logic Stress Test Business Flows..." -ForegroundColor Green
          Write-Host "This validates the actual business functionality rather than just container startup" -ForegroundColor Cyan
          
          $apiBase = "http://localhost:5000/api/ComplexLogicStressTest"
          $testResults = @()
          $overallSuccess = $true
          
          try {
            # CORRECT 8-STEP BUSINESS FLOW
            
            # Step 1: Configure Backpressure (100 msg/sec per logical queue)
            Write-Host "`nâš¡ Step 1: Configuring backpressure (100 msg/sec per logical queue)..." -ForegroundColor Yellow
            try {
              $backpressureConfig = @{
                PartitionCount = 100
                LogicalQueueCount = 1000
                MessagesPerSecondPerQueue = 100.0
              }
              $backpressureResponse = Invoke-RestMethod -Uri "$apiBase/step1/configure-backpressure" -Method POST -Body ($backpressureConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
              Write-Host "âœ… Step 1: Backpressure configuration: $($backpressureResponse.Status)" -ForegroundColor Green
              Write-Host "   Rate: $($backpressureResponse.Configuration.MessagesPerSecondPerQueue) msg/sec per queue, Total: $($backpressureResponse.TotalRateLimit) msg/sec" -ForegroundColor Cyan
              $testResults += @{Step="1-Backpressure"; Status=$backpressureResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 1 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="1-Backpressure"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
            # Step 2: Temporal Job Submission for 1M Messages (with top 1 and last 1 display)
            Write-Host "`nðŸ“ Step 2: Temporal job submission for 1M messages..." -ForegroundColor Yellow
            try {
              $messageConfig = @{
                MessageCount = 10000  # 10K for CI testing
                UseTemporalSubmission = $true
                PartitionCount = 100
                LogicalQueueCount = 1000
              }
              $productionResponse = Invoke-RestMethod -Uri "$apiBase/step2/temporal-submit-messages" -Method POST -Body ($messageConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 60
              Write-Host "âœ… Step 2: Message submission: $($productionResponse.Status)" -ForegroundColor Green
              Write-Host "   Messages: $($productionResponse.Metrics.messageCount.ToString('N0'))" -ForegroundColor Cyan
              
              # Display top 1 and last 1 message details as required
              if ($productionResponse.TopMessageSample) {
                Write-Host "   ðŸ“‹ Top 1 Message Details:" -ForegroundColor Yellow
                Write-Host "      Message ID: $($productionResponse.TopMessageSample.MessageID)" -ForegroundColor Cyan
                Write-Host "      Content: $($productionResponse.TopMessageSample.Content)" -ForegroundColor Cyan
                Write-Host "      Headers: $($productionResponse.TopMessageSample.Headers)" -ForegroundColor Cyan
              }
              
              if ($productionResponse.LastMessageSample) {
                Write-Host "   ðŸ“‹ Last 1 Message Details:" -ForegroundColor Yellow
                Write-Host "      Message ID: $($productionResponse.LastMessageSample.MessageID)" -ForegroundColor Cyan
                Write-Host "      Content: $($productionResponse.LastMessageSample.Content)" -ForegroundColor Cyan
                Write-Host "      Headers: $($productionResponse.LastMessageSample.Headers)" -ForegroundColor Cyan
              }
              
              $testResults += @{Step="2-Temporal_Submit"; Status=$productionResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 2 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="2-Temporal_Submit"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
            # Step 3: Temporal Job - Process Messages with Security Token
            Write-Host "`nðŸ”‘ Step 3: Temporal job to process messages with security token..." -ForegroundColor Yellow
            try {
              $processConfig = @{
                TestId = "ci-test-$(Get-Date -Format 'yyyyMMddHHmmss')"
                BatchSize = 100
              }
              $processResponse = Invoke-RestMethod -Uri "$apiBase/step3/temporal-process-messages" -Method POST -Body ($processConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
              Write-Host "âœ… Step 3: Temporal processing: $($processResponse.Status)" -ForegroundColor Green
              Write-Host "   Job ID: $($processResponse.TemporalJobId)" -ForegroundColor Cyan
              $testResults += @{Step="3-Temporal_Process"; Status=$processResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 3 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="3-Temporal_Process"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
            # Step 4: Flink Job - Concat 100 Messages
            Write-Host "`nðŸ”— Step 4: Flink job to concat 100 messages..." -ForegroundColor Yellow
            try {
              $concatConfig = @{
                BatchSize = 100
                SecurityTokenSource = "saved_token_service"
                LocalTestingApiEndpoint = "/api/batch/process"
                OutputTopic = "concat-output"
              }
              $concatResponse = Invoke-RestMethod -Uri "$apiBase/step4/flink-concat-job" -Method POST -Body ($concatConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
              Write-Host "âœ… Step 4: Flink concat job: $($concatResponse.Status)" -ForegroundColor Green
              Write-Host "   Job ID: $($concatResponse.JobId)" -ForegroundColor Cyan
              $testResults += @{Step="4-Flink_Concat"; Status=$concatResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 4 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="4-Flink_Concat"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
            # Step 5: Kafka In Sink - Retrieve from LocalTesting API
            Write-Host "`nðŸ“¥ Step 5: Create Kafka in sink to retrieve from LocalTesting API..." -ForegroundColor Yellow
            try {
              $sinkConfig = @{
                LocalTestingApiEndpoint = "/api/batch/process"
                PollIntervalMs = 1000
                OutputTopic = "api-retrieved-messages"
              }
              $sinkResponse = Invoke-RestMethod -Uri "$apiBase/step5/kafka-in-sink" -Method POST -Body ($sinkConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
              Write-Host "âœ… Step 5: Kafka in sink: $($sinkResponse.Status)" -ForegroundColor Green
              Write-Host "   Sink ID: $($sinkResponse.SinkId)" -ForegroundColor Cyan
              $testResults += @{Step="5-Kafka_InSink"; Status=$sinkResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 5 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="5-Kafka_InSink"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
            # Step 6: Flink Job - Split Messages
            Write-Host "`nâœ‚ï¸ Step 6: Flink job to split messages and add sending ID + logical queue name..." -ForegroundColor Yellow
            try {
              $splitConfig = @{
                InputTopic = "api-retrieved-messages"
                OutputTopic = "sample_response"
                AddSendingId = $true
                AddLogicalQueueName = $true
                UseCorrelationMatching = $true
              }
              $splitResponse = Invoke-RestMethod -Uri "$apiBase/step6/flink-split-job" -Method POST -Body ($splitConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
              Write-Host "âœ… Step 6: Flink split job: $($splitResponse.Status)" -ForegroundColor Green
              Write-Host "   Job ID: $($splitResponse.JobId)" -ForegroundColor Cyan
              $testResults += @{Step="6-Flink_Split"; Status=$splitResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 6 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="6-Flink_Split"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
            # Step 7: Write to sample_response Topic
            Write-Host "`nðŸ“¤ Step 7: Write messages to sample_response topic..." -ForegroundColor Yellow
            try {
              $writeConfig = @{
                TargetTopic = "sample_response"
                TopMessageCount = 10
                LastMessageCount = 10
              }
              $writeResponse = Invoke-RestMethod -Uri "$apiBase/step7/write-to-sample-response" -Method POST -Body ($writeConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
              Write-Host "âœ… Step 7: Write to sample_response: $($writeResponse.Status)" -ForegroundColor Green
              Write-Host "   Written messages: $($writeResponse.WrittenMessages.ToString('N0'))" -ForegroundColor Cyan
              $testResults += @{Step="7-Write_SampleResponse"; Status=$writeResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 7 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="7-Write_SampleResponse"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
            # Step 8: Verify Top 10 and Last 10 Messages
            Write-Host "`nðŸ” Step 8: Verifying top 10 and last 10 messages from sample_response topic..." -ForegroundColor Yellow
            try {
              $verificationConfig = @{
                TargetTopic = "sample_response"
                TopCount = 10
                LastCount = 10
                VerifyHeaders = $true
                VerifyContent = $true
              }
              $verificationResponse = Invoke-RestMethod -Uri "$apiBase/step8/verify-messages" -Method POST -Body ($verificationConfig | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
              Write-Host "âœ… Step 8: Message verification: $($verificationResponse.Status)" -ForegroundColor Green
              Write-Host "   Success Rate: $($verificationResponse.VerificationResult.SuccessRate.ToString('P1'))" -ForegroundColor Cyan
              
              # Display top 1 and last 1 message details as requested
              Write-Host "   ðŸ“‹ Message Verification Details:" -ForegroundColor Yellow
              
              if ($verificationResponse.TopMessageSample) {
                Write-Host "      ðŸ” Top 1 Message Details:" -ForegroundColor Green
                Write-Host "         Message ID: $($verificationResponse.TopMessageSample.MessageID)" -ForegroundColor Cyan
                Write-Host "         Content: $($verificationResponse.TopMessageSample.Content)" -ForegroundColor Cyan
                Write-Host "         Headers: $($verificationResponse.TopMessageSample.Headers)" -ForegroundColor Cyan
              }
              
              if ($verificationResponse.LastMessageSample) {
                Write-Host "      ðŸ”š Last 1 Message Details:" -ForegroundColor Green  
                Write-Host "         Message ID: $($verificationResponse.LastMessageSample.MessageID)" -ForegroundColor Cyan
                Write-Host "         Content: $($verificationResponse.LastMessageSample.Content)" -ForegroundColor Cyan
                Write-Host "         Headers: $($verificationResponse.LastMessageSample.Headers)" -ForegroundColor Cyan
              }
              
              $testResults += @{Step="8-Verify_Messages"; Status=$verificationResponse.Status; Success=$true}
            } catch {
              Write-Host "âŒ Step 8 failed: $($_.Exception.Message)" -ForegroundColor Red
              $testResults += @{Step="8-Verify_Messages"; Status="Failed"; Success=$false}
              $overallSuccess = $false
            }
            
          }
          catch {
            Write-Host "âŒ Business flow test failed: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "Response details: $($_.Exception.Response | Out-String)" -ForegroundColor Yellow
            $testResults += @{Step="Error"; Status="Failed"; Success=$false; Error=$_.Exception.Message}
            $overallSuccess = $false
          }
          
          # Summary Report
          Write-Host "`nðŸ“‹ Complex Logic Stress Test Business Flow Results:" -ForegroundColor Green
          Write-Host "=" * 60 -ForegroundColor Green
          
          $successfulSteps = ($testResults | Where-Object { $_.Success -eq $true }).Count
          $totalSteps = $testResults.Count
          
          foreach ($result in $testResults) {
            $status = if ($result.Success) { "âœ… PASSED" } else { "âŒ FAILED" }
            Write-Host "  $($result.Step): $status - $($result.Status)" -ForegroundColor $(if ($result.Success) { "Green" } else { "Red" })
          }
          
          Write-Host "=" * 60 -ForegroundColor Green
          Write-Host "Overall Result: $successfulSteps/$totalSteps steps passed" -ForegroundColor $(if ($overallSuccess) { "Green" } else { "Red" })
          
          if ($overallSuccess) {
            Write-Host "ðŸŽ‰ ALL BUSINESS FLOWS COMPLETED SUCCESSFULLY!" -ForegroundColor Green
            Write-Host "The LocalTesting environment successfully executed complex logic stress test scenarios" -ForegroundColor Cyan
          } else {
            Write-Host "âŒ SOME BUSINESS FLOWS FAILED" -ForegroundColor Red
            throw "Business flow validation failed - see test results above"
          }

      - name: Validate Aspire Environment Health and Performance
        run: |
          Write-Host "ðŸ” Final validation of Aspire environment health and performance..." -ForegroundColor Green
          
          # Show all running containers
          Write-Host "All running containers:" -ForegroundColor Yellow
          docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
          
          # Show container resource usage
          Write-Host "`nContainer resource usage:" -ForegroundColor Yellow
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
          
          # Check Docker system info
          Write-Host "`nDocker system info:" -ForegroundColor Yellow
          docker system info --format "{{.ServerVersion}}"
          
          Write-Host "âœ… LocalTesting environment validation completed successfully!" -ForegroundColor Green
          Write-Host "ðŸŽ‰ Both infrastructure containers AND business flows are working correctly!" -ForegroundColor Green

      - name: Summary Report
        run: |
          Write-Host "ðŸ“‹ LocalTesting Workflow Summary Report" -ForegroundColor Green
          Write-Host "=" * 50 -ForegroundColor Green
          Write-Host "âœ… Aspire environment startup: SUCCESS" -ForegroundColor Green
          Write-Host "âœ… Infrastructure container validation: SUCCESS" -ForegroundColor Green  
          Write-Host "âœ… Business flow execution: SUCCESS" -ForegroundColor Green
          Write-Host "âœ… Complex Logic Stress Test API: FUNCTIONAL" -ForegroundColor Green
          Write-Host "=" * 50 -ForegroundColor Green
          Write-Host "ðŸŽ¯ LocalTesting environment is production-ready for development and testing!" -ForegroundColor Green

      - name: Cleanup Aspire Environment
        if: always()
        run: |
          Write-Host "ðŸ§¹ Cleaning up Aspire environment..." -ForegroundColor Green
          
          # Stop the Aspire background process if it's still running
          try {
            if ($global:AspirePID) {
              Write-Host "Stopping Aspire process (PID: $global:AspirePID)..." -ForegroundColor Yellow
              Stop-Process -Id $global:AspirePID -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 5
            }
          }
          catch {
            Write-Host "Aspire process may have already stopped" -ForegroundColor Yellow
          }
          
          # Stop any remaining dotnet processes that might be running
          try {
            $dotnetProcesses = Get-Process -Name "dotnet" -ErrorAction SilentlyContinue
            if ($dotnetProcesses) {
              Write-Host "Stopping remaining dotnet processes..." -ForegroundColor Yellow
              $dotnetProcesses | Stop-Process -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 5
            }
          }
          catch {
            Write-Host "No additional dotnet processes to stop" -ForegroundColor Yellow
          }
          
          # Stop all containers that might have been started
          Write-Host "Stopping all Docker containers..." -ForegroundColor Yellow
          docker ps -q | ForEach-Object { docker stop $_ } 2>$null
          
          # Clean up any dangling containers
          Write-Host "Cleaning up containers..." -ForegroundColor Yellow
          docker container prune -f 2>$null
          
          # Clean up any log files
          try {
            Push-Location LocalTesting/LocalTesting.AppHost -ErrorAction SilentlyContinue
            if (Test-Path "aspire_output.log") { Remove-Item "aspire_output.log" -Force }
            if (Test-Path "aspire_error.log") { Remove-Item "aspire_error.log" -Force }
            Pop-Location
          }
          catch {
            Write-Host "No log files to clean up" -ForegroundColor Yellow
          }
          
          Write-Host "âœ… Cleanup completed!" -ForegroundColor Green

      - name: Upload LocalTesting test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: local-testing-results
          path: |
            **/*.log
            **/*.txt
            LocalTesting/**/bin/Release/net9.0/**
          retention-days: 7