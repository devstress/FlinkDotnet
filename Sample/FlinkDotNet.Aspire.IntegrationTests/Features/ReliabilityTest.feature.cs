// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by Reqnroll (https://www.reqnroll.net/).
//      Reqnroll Version:2.0.0.0
//      Reqnroll Generator Version:2.0.0.0
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
namespace FlinkDotNet.Aspire.IntegrationTests.Features
{
    using Reqnroll;
    using System;
    using System.Linq;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Reqnroll", "2.0.0.0")]
    [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [Xunit.TraitAttribute("Category", "reliability_test")]
    [Xunit.TraitAttribute("Category", "fault_tolerance")]
    public partial class ReliabilityTest_FaultToleranceAndRecoveryFeature : object, Xunit.IClassFixture<ReliabilityTest_FaultToleranceAndRecoveryFeature.FixtureData>, Xunit.IAsyncLifetime
    {
        
        private static global::Reqnroll.ITestRunner testRunner;
        
        private static string[] featureTags = new string[] {
                "reliability_test",
                "fault_tolerance"};
        
        private Xunit.Abstractions.ITestOutputHelper _testOutputHelper;
        
#line 1 "ReliabilityTest.feature"
#line hidden
        
        public ReliabilityTest_FaultToleranceAndRecoveryFeature(ReliabilityTest_FaultToleranceAndRecoveryFeature.FixtureData fixtureData, Xunit.Abstractions.ITestOutputHelper testOutputHelper)
        {
            this._testOutputHelper = testOutputHelper;
        }
        
        public static async System.Threading.Tasks.Task FeatureSetupAsync()
        {
            testRunner = global::Reqnroll.TestRunnerManager.GetTestRunnerForAssembly();
            global::Reqnroll.FeatureInfo featureInfo = new global::Reqnroll.FeatureInfo(new System.Globalization.CultureInfo("en-US"), "Features", "Reliability Test - Fault Tolerance and Recovery", "  As a Flink.NET user\n  I want to handle 10% failure rates with backpressure and " +
                    "rebalancing\n  So that I can ensure system reliability under adverse conditions", global::Reqnroll.ProgrammingLanguage.CSharp, featureTags);
            await testRunner.OnFeatureStartAsync(featureInfo);
        }
        
        public static async System.Threading.Tasks.Task FeatureTearDownAsync()
        {
            await testRunner.OnFeatureEndAsync();
            global::Reqnroll.TestRunnerManager.ReleaseTestRunner(testRunner);
            testRunner = null;
        }
        
        public async System.Threading.Tasks.Task TestInitializeAsync()
        {
        }
        
        public async System.Threading.Tasks.Task TestTearDownAsync()
        {
            await testRunner.OnScenarioEndAsync();
        }
        
        public void ScenarioInitialize(global::Reqnroll.ScenarioInfo scenarioInfo)
        {
            testRunner.OnScenarioInitialize(scenarioInfo);
            testRunner.ScenarioContext.ScenarioContainer.RegisterInstanceAs<Xunit.Abstractions.ITestOutputHelper>(_testOutputHelper);
        }
        
        public async System.Threading.Tasks.Task ScenarioStartAsync()
        {
            await testRunner.OnScenarioStartAsync();
        }
        
        public async System.Threading.Tasks.Task ScenarioCleanupAsync()
        {
            await testRunner.CollectScenarioErrorsAsync();
        }
        
        public virtual async System.Threading.Tasks.Task FeatureBackgroundAsync()
        {
#line 7
  #line hidden
#line 8
    await testRunner.GivenAsync("the Flink cluster is running with fault tolerance enabled", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 9
    await testRunner.AndAsync("Kafka topics are configured for reliability testing", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 10
    await testRunner.AndAsync("Dead Letter Queue (DLQ) topic is available", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 11
    await testRunner.AndAsync("Consumer group rebalancing is enabled", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
        }
        
        async System.Threading.Tasks.Task Xunit.IAsyncLifetime.InitializeAsync()
        {
            await this.TestInitializeAsync();
        }
        
        async System.Threading.Tasks.Task Xunit.IAsyncLifetime.DisposeAsync()
        {
            await this.TestTearDownAsync();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Handle 10% Message Failures with DLQ Processing")]
        [Xunit.TraitAttribute("FeatureTitle", "Reliability Test - Fault Tolerance and Recovery")]
        [Xunit.TraitAttribute("Description", "Handle 10% Message Failures with DLQ Processing")]
        [Xunit.TraitAttribute("Category", "reliability")]
        [Xunit.TraitAttribute("Category", "failure_injection")]
        [Xunit.TraitAttribute("Category", "dlq")]
        public async System.Threading.Tasks.Task Handle10MessageFailuresWithDLQProcessing()
        {
            string[] tagsOfScenario = new string[] {
                    "reliability",
                    "failure_injection",
                    "dlq"};
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Handle 10% Message Failures with DLQ Processing", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 14
  this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 7
  await this.FeatureBackgroundAsync();
#line hidden
#line 15
    await testRunner.GivenAsync("I have a Kafka input topic \"reliability-input\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 16
    await testRunner.AndAsync("I have a Kafka output topic \"reliability-output\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 17
    await testRunner.AndAsync("I have a Dead Letter Queue topic \"reliability-dlq\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 18
    await testRunner.AndAsync("I configure a 10% artificial failure rate in message processing", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 19
    await testRunner.WhenAsync("I produce 1,000,000 messages to the input topic", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
                global::Reqnroll.Table table50 = new global::Reqnroll.Table(new string[] {
                            "Step",
                            "Operation",
                            "Configuration"});
                table50.AddRow(new string[] {
                            "1",
                            "KafkaSource",
                            "topic=reliability-input, fault-tolerance=enabled"});
                table50.AddRow(new string[] {
                            "2",
                            "FaultInjector",
                            "failure-rate=10%, failure-type=random"});
                table50.AddRow(new string[] {
                            "3",
                            "BackpressureProcessor",
                            "handle slow processing scenarios"});
                table50.AddRow(new string[] {
                            "4",
                            "RebalancingProcessor",
                            "support consumer group rebalancing"});
                table50.AddRow(new string[] {
                            "5",
                            "ConditionalSink",
                            "success→reliability-output, failure→reliability-dlq"});
#line 20
    await testRunner.AndAsync("I start the Flink streaming job with fault injection enabled:", ((string)(null)), table50, "And ");
#line hidden
#line 27
    await testRunner.ThenAsync("approximately 900,000 messages (90%) should be processed to output topic", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 28
    await testRunner.AndAsync("approximately 100,000 messages (10%) should be sent to DLQ topic", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 29
    await testRunner.AndAsync("the total message count should equal 1,000,000 (no lost messages)", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 30
    await testRunner.AndAsync("processing should complete despite failures", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 31
    await testRunner.AndAsync("system should maintain stability throughout the test", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Handle Backpressure with Consumer Rebalancing")]
        [Xunit.TraitAttribute("FeatureTitle", "Reliability Test - Fault Tolerance and Recovery")]
        [Xunit.TraitAttribute("Description", "Handle Backpressure with Consumer Rebalancing")]
        [Xunit.TraitAttribute("Category", "reliability")]
        [Xunit.TraitAttribute("Category", "backpressure")]
        [Xunit.TraitAttribute("Category", "rebalancing")]
        public async System.Threading.Tasks.Task HandleBackpressureWithConsumerRebalancing()
        {
            string[] tagsOfScenario = new string[] {
                    "reliability",
                    "backpressure",
                    "rebalancing"};
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Handle Backpressure with Consumer Rebalancing", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 34
  this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 7
  await this.FeatureBackgroundAsync();
#line hidden
#line 35
    await testRunner.GivenAsync("I have a multi-partition Kafka setup", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 36
    await testRunner.AndAsync("I configure slow processing to induce backpressure", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 37
    await testRunner.AndAsync("Consumer group has multiple consumers for rebalancing", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 38
    await testRunner.WhenAsync("I start producing messages at high rate (5,000 msg/sec)", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 39
    await testRunner.AndAsync("I configure processing to be slower than input rate (2,000 msg/sec)", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
                global::Reqnroll.Table table51 = new global::Reqnroll.Table(new string[] {
                            "Action",
                            "Timing",
                            "Expected Behavior"});
                table51.AddRow(new string[] {
                            "Add consumer instance",
                            "After 100K messages",
                            "Partition reassignment"});
                table51.AddRow(new string[] {
                            "Remove consumer instance",
                            "After 500K messages",
                            "Partition rebalancing"});
                table51.AddRow(new string[] {
                            "Network partition simulation",
                            "After 750K messages",
                            "Failover and recovery"});
#line 40
    await testRunner.AndAsync("I trigger consumer rebalancing during processing by:", ((string)(null)), table51, "And ");
#line hidden
#line 45
    await testRunner.ThenAsync("the system should handle backpressure gracefully", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 46
    await testRunner.AndAsync("consumer rebalancing should occur without message loss", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 47
    await testRunner.AndAsync("processing should resume after each rebalancing event", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 48
    await testRunner.AndAsync("end-to-end message delivery should be maintained", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 49
    await testRunner.AndAsync("no duplicate processing should occur during rebalancing", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Validate Fault Recovery from Checkpoints")]
        [Xunit.TraitAttribute("FeatureTitle", "Reliability Test - Fault Tolerance and Recovery")]
        [Xunit.TraitAttribute("Description", "Validate Fault Recovery from Checkpoints")]
        [Xunit.TraitAttribute("Category", "reliability")]
        [Xunit.TraitAttribute("Category", "fault_recovery")]
        [Xunit.TraitAttribute("Category", "checkpoint")]
        public async System.Threading.Tasks.Task ValidateFaultRecoveryFromCheckpoints()
        {
            string[] tagsOfScenario = new string[] {
                    "reliability",
                    "fault_recovery",
                    "checkpoint"};
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Validate Fault Recovery from Checkpoints", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 52
  this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 7
  await this.FeatureBackgroundAsync();
#line hidden
#line 53
    await testRunner.GivenAsync("I have checkpointing enabled with 30-second intervals", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 54
    await testRunner.AndAsync("I have a long-running processing job configured", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 55
    await testRunner.WhenAsync("I start processing 1,000,000 messages", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
                global::Reqnroll.Table table52 = new global::Reqnroll.Table(new string[] {
                            "Fault Type",
                            "Timing",
                            "Recovery Expectation"});
                table52.AddRow(new string[] {
                            "TaskManager failure",
                            "After 250K messages",
                            "Restart from last checkpoint"});
                table52.AddRow(new string[] {
                            "Network partition",
                            "After 500K messages",
                            "Automatic reconnection"});
                table52.AddRow(new string[] {
                            "Processing node failure",
                            "After 750K messages",
                            "Failover to healthy nodes"});
#line 56
    await testRunner.AndAsync("I introduce system faults at different stages:", ((string)(null)), table52, "And ");
#line hidden
#line 61
    await testRunner.ThenAsync("the system should recover from each fault automatically", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 62
    await testRunner.AndAsync("processing should resume from the last successful checkpoint", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 63
    await testRunner.AndAsync("no messages should be lost during fault recovery", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 64
    await testRunner.AndAsync("the final output count should match input count (accounting for DLQ)", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 65
    await testRunner.AndAsync("recovery time should be less than 2 minutes per fault", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Monitor System Health During Reliability Testing")]
        [Xunit.TraitAttribute("FeatureTitle", "Reliability Test - Fault Tolerance and Recovery")]
        [Xunit.TraitAttribute("Description", "Monitor System Health During Reliability Testing")]
        [Xunit.TraitAttribute("Category", "reliability")]
        [Xunit.TraitAttribute("Category", "monitoring")]
        [Xunit.TraitAttribute("Category", "metrics")]
        public async System.Threading.Tasks.Task MonitorSystemHealthDuringReliabilityTesting()
        {
            string[] tagsOfScenario = new string[] {
                    "reliability",
                    "monitoring",
                    "metrics"};
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Monitor System Health During Reliability Testing", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 68
  this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 7
  await this.FeatureBackgroundAsync();
#line hidden
#line 69
    await testRunner.GivenAsync("I have monitoring and metrics collection enabled", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 70
    await testRunner.WhenAsync("I run the reliability test with 10% failures", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
                global::Reqnroll.Table table53 = new global::Reqnroll.Table(new string[] {
                            "Metric",
                            "Expected Behavior"});
                table53.AddRow(new string[] {
                            "Message processing rate",
                            "Maintains target rate despite failures"});
                table53.AddRow(new string[] {
                            "Error rate",
                            "Stays around 10% as configured"});
                table53.AddRow(new string[] {
                            "Backpressure indicators",
                            "Shows when processing lags behind input"});
                table53.AddRow(new string[] {
                            "Consumer lag",
                            "Remains within acceptable bounds"});
                table53.AddRow(new string[] {
                            "DLQ message count",
                            "Accumulates failed messages correctly"});
                table53.AddRow(new string[] {
                            "System resource usage",
                            "Remains stable under fault conditions"});
#line 71
    await testRunner.ThenAsync("I should be able to monitor:", ((string)(null)), table53, "Then ");
#line hidden
#line 79
    await testRunner.AndAsync("alerts should trigger when error rates exceed thresholds", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 80
    await testRunner.AndAsync("dashboards should show real-time processing health", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 81
    await testRunner.AndAsync("historical metrics should be preserved for analysis", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Verify Top 10 and Last 10 Messages with Content and Headers - Reliability Test")]
        [Xunit.TraitAttribute("FeatureTitle", "Reliability Test - Fault Tolerance and Recovery")]
        [Xunit.TraitAttribute("Description", "Verify Top 10 and Last 10 Messages with Content and Headers - Reliability Test")]
        [Xunit.TraitAttribute("Category", "reliability")]
        [Xunit.TraitAttribute("Category", "message_verification")]
        [Xunit.TraitAttribute("Category", "content_headers")]
        public async System.Threading.Tasks.Task VerifyTop10AndLast10MessagesWithContentAndHeaders_ReliabilityTest()
        {
            string[] tagsOfScenario = new string[] {
                    "reliability",
                    "message_verification",
                    "content_headers"};
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Verify Top 10 and Last 10 Messages with Content and Headers - Reliability Test", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 84
  this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 7
  await this.FeatureBackgroundAsync();
#line hidden
#line 85
    await testRunner.GivenAsync("I have processed 1,000,000 messages through the reliability pipeline with 10% fai" +
                        "lures", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 86
    await testRunner.AndAsync("all messages have been properly routed to success or DLQ topics", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 87
    await testRunner.WhenAsync("I retrieve the first 10 successfully processed messages from the output topic", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
                global::Reqnroll.Table table54 = new global::Reqnroll.Table(new string[] {
                            "Message ID",
                            "Content",
                            "Headers"});
                table54.AddRow(new string[] {
                            "1",
                            "Reliability msg 1: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "2",
                            "Reliability msg 2: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "3",
                            "Reliability msg 3: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "4",
                            "Reliability msg 4: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "5",
                            "Reliability msg 5: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "6",
                            "Reliability msg 6: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "7",
                            "Reliability msg 7: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "8",
                            "Reliability msg 8: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "9",
                            "Reliability msg 9: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
                table54.AddRow(new string[] {
                            "10",
                            "Reliability msg 10: Successfully processed through fault-tolerant pipeline",
                            "kafka.topic=reliability-output; fault.injected=false; dlq.routed=false"});
#line 88
    await testRunner.ThenAsync("I can display the top 10 first processed reliability messages table:", ((string)(null)), table54, "Then ");
#line hidden
#line 100
    await testRunner.WhenAsync("I retrieve the last 10 successfully processed messages from the output topic", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
                global::Reqnroll.Table table55 = new global::Reqnroll.Table(new string[] {
                            "Message ID",
                            "Content",
                            "Headers"});
                table55.AddRow(new string[] {
                            "999991",
                            "Reliability msg 999991: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999992",
                            "Reliability msg 999992: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999993",
                            "Reliability msg 999993: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999994",
                            "Reliability msg 999994: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999995",
                            "Reliability msg 999995: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999996",
                            "Reliability msg 999996: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999997",
                            "Reliability msg 999997: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999998",
                            "Reliability msg 999998: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "999999",
                            "Reliability msg 999999: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
                table55.AddRow(new string[] {
                            "1000000",
                            "Reliability msg 1000000: Final success after complete fault tolerance testing",
                            "kafka.topic=reliability-output; fault.recovery=completed; checkpoint.restored=tru" +
                                "e"});
#line 101
    await testRunner.ThenAsync("I can display the top 10 last processed reliability messages table:", ((string)(null)), table55, "Then ");
#line hidden
#line 113
    await testRunner.AndAsync("all messages should contain reliability-specific content and headers", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 114
    await testRunner.AndAsync("all headers should include fault injection and recovery status", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("Reqnroll", "2.0.0.0")]
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        public class FixtureData : object, Xunit.IAsyncLifetime
        {
            
            async System.Threading.Tasks.Task Xunit.IAsyncLifetime.InitializeAsync()
            {
                await ReliabilityTest_FaultToleranceAndRecoveryFeature.FeatureSetupAsync();
            }
            
            async System.Threading.Tasks.Task Xunit.IAsyncLifetime.DisposeAsync()
            {
                await ReliabilityTest_FaultToleranceAndRecoveryFeature.FeatureTearDownAsync();
            }
        }
    }
}
#pragma warning restore
#endregion
